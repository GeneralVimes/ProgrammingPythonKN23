import time
# Рекурсія

#Нерекурсивний спосіб знаходження суми чисел
def sum_var1(n):
	res=0
	#пробігаємо по всіх числах від 1 до n та додаємо їх в суму
	for i in range(1,n+1):
		res+=i
	return res

# print(sum_var1(5))

# Ідея для застосування рекурсії
# Якщо в нас є сума n чисел:
# 1+2+3+....+(n-2)+(n-1)+n
# Ми можемо цю суму записати так
# (1+2+3+....+(n-2)+(n-1))+n
# Так сума n чисел виражається через суму n-1 чисел
# і ми момемо написати таку функцію
def sum_var2(n):
	print("Знаходимо суму ",n," чисел")
	if n==0:
		print("Сума 0 чисел дорівнює 0")
		return 0
	print("для цього треба ", n, " додати до суми ", n-1, " чисел")
	res=sum_var2(n-1)+n
	print("Для n=",n," повертаємо", res)
	return res

# print(sum_var2(5))


# Задача: у клітині з координатами (0,0) стоїть фішка, яка может рухатися лише на 1 по х чи по у у додтньому напряму
# Знайти кількість способів, якими вона можна дійти до клітини (3,3)? Або до клітини (8,8)?
# Помічаємо, що у клітину (x,y) можна дістатися лише з клітин (x-1, y) (зліва) або (x, y-1) (згори)
# Отже, кількість способів для клітини (x,y) має дорівнювати сумі кількості спообів для цих двох клітин
# Також є єдиний спосіб дістатися клітини на вісях координат
def ways(x,y):
	# print("calculating ways",x,y)
	if x==0 or y==0:
		return 1
	return ways(x-1, y)+ways(x, y-1)+ways(x-1, y-1)

# print(ways(4,4))
# print(ways(8,8))

# ключова ідея оптимізація рекурсійних алогритмів - запам'ятовувати обчислувані значення та використовувати їх при наступній зустрічі
memory={}
def ways_mem(x,y):
	key=str(x)+"_"+str(y)
	if key in memory:
		return memory[key]
	# print("calculating ways",x,y)
	if x==0 or y==0:
		return 1
	res = ways_mem(x-1, y)+ways_mem(x, y-1)+ways_mem(x-1, y-1)
	memory[key]=res
	return res


t0=time.time()
print(ways(11,11))
print(time.time()-t0)

t0=time.time()
print(ways_mem(11,11))
print(time.time()-t0)
