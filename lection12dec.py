import random
import time

#задача: дан масив чисел 
a=[2, 5, 7, 18, 4, 2, 3, 1]
#знайти пару елементів, чия сума буде дорівнювати 10
# як це зробити?
# варіант 1 - для кожного елементу пробыгти масив та подивитися чи знайдеться його оповнення до 10
s = 10;#це цільова сума
def find_pair_of_sum(a, s):
	for i in range(len(a)):#номер першого елементу пробігає від 0 до номер останнього елементу у а
		# для кожного i-го елементу треба пробігти внутрішній цикл щоб побачити, чи знайдеться його доповнення до 10-ти
		for j in range(i+1, len(a)):
			# тепер можна перевірити суму
			if a[i]+a[j]==s:
				return (i,j) #у Python можна повертати одразу пару чисел як результат функції
	return None #якщо припробіганні пари не знайшщлося, то повертаємо None




# обчислювальна складність цього алгоритму буде O(N^2)
# Як знайти те саме, але за один прохід по масиву (із використанням додаткової пам'яті)
# Якщо всі числа цілі та невід'ємні, можна використати додатковий масив довжини s+1, назвемо його b
# Елемент масиву b[k] - це позиція доповлення числа k до суми s у масиві a
# Пробігаючи по масиву a ми одразу будемо перевіряти, чи не зустрічалося раніше доповнення до суми s
# а також будемо зберігати позиції поточних чисел для пошуку їх доповнень
def find_pair_of_sum_fast(a, s):
	# спочатку створюємо масив b
	b=[-1]*(s+1)
	for i in range(len(a)):#пробігаємо по масиву a
		if a[i]<=s:
			c = s-a[i] #знаходимо доповнення поточного елементу масиву а доцільової суми
			# перевіряємо, чи зустрічалося це доповнення раніше
			if b[a[i]]!=-1:
				return (b[a[i]],i)#якщо воно зустрічалося, виводимо результат
			b[c]=i#записуємо, де ми зножемо знайти доповнення до числа c
	return None #якщо припробіганні пари не знайшщлося, то повертаємо None


# Щоб зробити наш алгоритм більш угіверсальним, можна використати концепцію хеш-таблиць
# Якщо у масиві ми можемо звертатися до комірок з цілими індексами
# то у хеш-таблиць адресою комірки може бути будь-який об'єкт, і все одно час звертання буде не залежати від її обсягу

# ця фугкція буде працювати і з додатними і з дробовими числами
def find_pair_of_sum_universal(a, s):
	# спочатку створюємо словник d
	d={}
	for i in range(len(a)):#пробігаємо по масиву a
		c = s-a[i] #знаходимо доповнення поточного елементу масиву а доцільової суми
		# перевіряємо, чи зустрічалося це доповнення раніше
		if a[i] in d:
			return (d[a[i]],i)#якщо воно зустрічалося, виводимо результат
		d[c]=i#записуємо, де ми зножемо знайти доповнення до числа c
	return None #якщо припробіганні пари не знайшлося, то повертаємо None


print(find_pair_of_sum_universal([2, 5, 7, 18, 4, 2, -8, 1], 10))
print(find_pair_of_sum_universal([2.5, 5, 7.5, 18, 4, 2, -8, 1], 10))


# print(find_pair_of_sum([2, 5, 7, 18, 4, 2, 3, 1], 11))
# print(find_pair_of_sum_fast([2, 5, 7, 18, 4, 2, 3, 1], 11))

#s = 10
#a = []
#for k in range(10):
#	a.append(random.randint(0, s))
#
## 
#a=[9, 7, 6, 10, 8, 7, 8, 3, 5, 1]
#print(a)
## a = [15, 28, 19, 6, 83, 32, 49, 33, 60, 60, 83, 16, 87, 67, 21, 44, 0, 90, 8, 49, 20, 0, 4, 33, 81, 80, 79, 33, 59, 100, 41, 50, 62, 55, 16, 90, 4, 32, 75, 36, 52, 80, 67, 96, 52, 98, 100, 12, 49, 50, 88, 20, 43, 13, 5, 90, 92, 60, 92, 36, 4, 92, 37, 35, 90, 97, 38, 51, 44, 92, 55, 35, 21, 27, 58, 49, 67, 37, 58, 66, 22, 82, 6, 43, 25, 77, 95, 85, 63, 24, 36, 64, 23, 58, 43, 14, 24, 78, 3, 49]
#print(find_pair_of_sum(a, s))
#print(find_pair_of_sum_fast(a, s))
