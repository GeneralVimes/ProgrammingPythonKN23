# Бінарні оператори
# Виконують дії з бінарним поданням числа
# Бінарні
# & - AND
# | - OR
# ^ - XOR (виключне OR)
# << - здвиг ліворуч
# >> - здвиг праворуч

# Унарні
# ~ - NOT

print(27&7)
print(27|7)
print(27^7)
print(28^7)


print(120^127)
print(7^127)

print(27<<2)
print(27>>2)

# Задача. Дане число n
# Замінити в ньому 5й біт з кінця (останній біт вважаємо 1м з кінця) на протилежний
# Заміна бута на протидежний можна виконати, якщо виконати XOR (^) з двійковим числом 00010000
# Таке число (00010000) можна отримати, якщо одиницю звинути вліво на 4
# Отже, заміна 5го з кінця біта на протилежне буде зроблено через
# n^(1<<4)
print(108^(1<<4))
print(27^(1<<4))

# Унарний оператор NOT ~
# міняє всі біти на протилежні
print(~10)

# Задача: закодувати шаховий хід у 12 бітів та розкодувати його
# 1. Перенумероєжмо вертикалі abcdefgh з 0 до 7. На позначення вертикалі треба по 3 біти
# 2. Перенумероєжмо горизонталі 12345678 з 0 до 7. На позначення горизонталі треба по 3 біти
# 3. Зліплюємо разом 4 рази по 3 біти: клітина початку ходу та клітина кінця ходу. В результаті отримуємо число
#
def encode_move(move_str):#move_str виглядає як 5 символьний рядок з дефісом посередині 
	# "c4-e5"
	vert_names="abcdefgh"
	horz_names="12345678"
	res=0
	#влітинка початку ходу
	start_vert_id = vert_names.find(move_str[0])
	res|=start_vert_id#додаємо код вертикалі до res
	res<<=3#сдвигаємо біти в res на 3 позиції ліворуч, щоб можна було далі туди додавати
	start_horz_id = horz_names.find(move_str[1])
	res|=start_horz_id#додаємо код горизонталі до res
	res<<=3#сдвигаємо біти в res на 3 позиції ліворуч, щоб можна було далі туди додавати
	# клітинка кінця ходу
	end_vert_id = vert_names.find(move_str[3])
	res|=end_vert_id#додаємо код вертикалі до res
	res<<=3#сдвигаємо біти в res на 3 позиції ліворуч, щоб можна було далі туди додавати
	end_horz_id = horz_names.find(move_str[4])
	res|=end_horz_id#додаємо код горизонталі до res
	return res



#щоб декодувати хід у вигляді єдиного ичлса і отримати його текстове позначення
def decode_move(move_num):
	vert_names="abcdefgh"
	horz_names="12345678"	
	res=""
	# дізнаємося останні три біта числа 
	# для цього застосуємо оператор & з числом 7 (яке у двійокому вигляді виглядає як 00...00111)
	end_horz_id = move_num&7#це буде номер горизонталі другої клітини
	# дізнаємося номер вертикалі другої клітини
	end_vert_id = (move_num&(7<<3))>>3#це буде номер горизонталі другої клітини
	# дізнаємося номер горизонталі першої клітини
	start_horz_id = (move_num&(7<<6))>>6
	# дізнаємося номер вертикалі першої клітини
	start_vert_id = (move_num&(7<<9))>>9

	res=vert_names[start_vert_id]+horz_names[start_horz_id]+"-"+vert_names[end_vert_id]+horz_names[end_horz_id]


	return res

move_string = "c4-e5"
print(move_string)
move_num = encode_move(move_string)
print(move_num)
new_move_string = decode_move(move_num)
print(new_move_string)