# Бінарні оператори
# Виконують дії з бінарним поданням числа
# Бінарні
# & - AND
# | - OR
# ^ - XOR (виключне OR)
# << - здвиг ліворуч
# >> - здвиг праворуч

# Унарні
# ~ - NOT

print(27&7)
print(27|7)
print(27^7)
print(28^7)


print(120^127)
print(7^127)

print(27<<2)
print(27>>2)

# Задача. Дане число n
# Замінити в ньому 5й біт з кінця (останній біт вважаємо 1м з кінця) на протилежний
# Заміна бута на протидежний можна виконати, якщо виконати XOR (^) з двійковим числом 00010000
# Таке число (00010000) можна отримати, якщо одиницю звинути вліво на 4
# Отже, заміна 5го з кінця біта на протилежне буде зроблено через
# n^(1<<4)
print(108^(1<<4))
print(27^(1<<4))

# Унарний оператор NOT ~
# міняє всі біти на протилежні
print(~10)

# Задача: закодувати шаховий хід у 12 бітів та розкодувати його
# 1. Перенумероєжмо вертикалі abcdefgh з 0 до 7. На позначення вертикалі треба по 3 біти
# 2. Перенумероєжмо горизонталі 12345678 з 0 до 7. На позначення горизонталі треба по 3 біти
# 3. Зліплюємо разом 4 рази по 3 біти: клітина початку ходу та клітина кінця ходу. В результаті отримуємо число
#
def encode_move(move_str):#move_str виглядає як 5 символьний рядок з дефісом посередині 
	# "c4-e5"
	vert_names="abcdefgh"
	horz_names="12345678"
	res=0
	#влітинка початку ходу
	start_vert_id = vert_names.find(move_str[0])
	res|=start_vert_id#додаємо код вертикалі до res
	res<<=3#сдвигаємо біти в res на 3 позиції ліворуч, щоб можна було далі туди додавати
	start_horz_id = horz_names.find(move_str[1])
	res|=start_horz_id#додаємо код горизонталі до res
	res<<=3#сдвигаємо біти в res на 3 позиції ліворуч, щоб можна було далі туди додавати
	# клітинка кінця ходу
	end_vert_id = vert_names.find(move_str[3])
	res|=end_vert_id#додаємо код вертикалі до res
	res<<=3#сдвигаємо біти в res на 3 позиції ліворуч, щоб можна було далі туди додавати
	end_horz_id = horz_names.find(move_str[4])
	res|=end_horz_id#додаємо код горизонталі до res
	return res


print("c4-e5")
print(encode_move("c4-e5"))